<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Transfert audio</title>
  <meta name="theme-color" content="#0b0d10" />
  <style>
    :root {
      --bg: #0b0d10;
      --panel: #121418;
      --fg: #c9d1d9;
      --muted: #7d8590;
      --accent: #3b82f6;
      --danger: #ef4444;
      --ok: #10b981;
      --border: #23262b;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; background: var(--bg); color: var(--fg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      -webkit-user-select: none; user-select: none;
      -webkit-tap-highlight-color: transparent;
    }
    .wrap {
      min-height: 100%; display: grid; grid-template-rows: auto 1fr auto; gap: 16px;
    }
    header {
      padding: 12px 16px; display: flex; gap: 12px; align-items: center; justify-content: space-between;
      background: var(--panel); border-bottom: 1px solid var(--border);
    }
    .title { font-weight: 600; letter-spacing: .2px; }
    .controls { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; }
    select, input[type="number"] {
      background: #1a1d22; color: var(--fg); border: 1px solid var(--border); border-radius: 10px; padding: 8px 10px; font-size: 14px;
    }
    main { display: grid; place-items: center; padding: 16px; }
    .board { width: min(920px, 92vw); background: var(--panel); border: 1px solid var(--border); border-radius: 18px; padding: 18px; box-shadow: 0 10px 30px rgba(0,0,0,.25); }
    .hint { text-align: center; color: var(--muted); margin: 0 0 14px; font-size: clamp(14px, 2.8vw, 18px); }
    .canvas-wrap { position: relative; width: 100%; height: 220px; background: #0e1116; border: 1px solid var(--border); border-radius: 14px; overflow: hidden; }
    canvas { display: block; width: 100%; height: 100%; }
    .cursor-bar { position: absolute; top: 0; bottom: 0; width: 2px; background: var(--accent); transform: translateX(-1px); pointer-events: none; }
    .status {
      min-height: 22px; text-align: center; margin-top: 10px; font-size: 14px; color: var(--muted);
    }
    .actions { display: grid; grid-template-columns: 1fr auto 1fr; align-items: center; gap: 12px; margin-top: 16px; }
    .spacer { height: 1px; background: var(--border); }
    .record-btn {
      justify-self: center; width: 132px; height: 132px; border-radius: 999px; border: none; cursor: pointer;
      background: radial-gradient(circle at 30% 30%, #ff7070, var(--danger));
      box-shadow: 0 12px 30px rgba(239, 68, 68, .35), inset 0 0 0 6px rgba(255,255,255,.06);
      transition: transform .06s ease, filter .2s ease;
    }
    .record-btn:active { transform: scale(.98); filter: saturate(1.2); }
    .recording .record-btn { box-shadow: 0 16px 40px rgba(239, 68, 68, .6), inset 0 0 0 6px rgba(255,255,255,.12); }
    footer { padding: 10px 16px; color: var(--muted); text-align: center; font-size: 12px; }
    .pill { display: inline-flex; gap: 8px; align-items: center; background: #0e141a; border: 1px solid var(--border); border-radius: 999px; padding: 6px 10px; font-size: 12px; }
    .dot { width: 8px; height: 8px; border-radius: 999px; background: var(--muted); }
    .dot.ok { background: var(--ok); }
    .row { display:flex; gap:10px; align-items:center; }
    .kbd { padding: 2px 6px; border-radius: 6px; background: #0e1116; border: 1px solid var(--border); font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; font-size: 12px; color: var(--fg); }
  </style>
</head>
<body>
  <div class="wrap" id="app">
    <header>
      <div class="title">Transfert audio</div>
      <div class="controls">
        <label class="row">Mode
          <select id="mode">
            <option value="sound_track">son intégral</option>
            <option value="sound_graph">niveau sonore</option>
          </select>
        </label>
        <label class="row">Durée max (s)
          <input id="maxSec" type="number" min="1" max="10" step="1" value="3" />
        </label>
        <span class="pill" id="sockState"><span class="dot" id="sockDot"></span> Socket</span>
      </div>
    </header>

    <main>
      <div class="board">
        <p class="hint" id="hint">Restez appuyé pour transmettre un son</p>
        <div class="canvas-wrap">
          <canvas id="scope" width="1200" height="300" aria-label="graphe du niveau sonore"></canvas>
          <div class="cursor-bar" id="cursor"></div>
        </div>
        <div class="status" id="status"></div>
        <div class="actions">
          <div class="spacer"></div>
          <button class="record-btn" id="recordBtn" aria-label="Maintenir pour enregistrer"></button>
          <div class="spacer"></div>
        </div>
      </div>
    </main>

    <footer>
      <span class="kbd">Astuce</span> Maintenez le bouton rouge (<span class="kbd">Espace</span> aussi) pour enregistrer. Relâchez pour envoyer.
    </footer>
  </div>

  <!-- Socket.IO (servi via votre serveur Node.js: /socket.io/socket.io.js) -->
  <script src="/socket.io/socket.io.js"></script>
  <script>
  ;(() => {
    /**
     * Page d'enregistrement audio + envoi Socket.IO
     * -------------------------------------------------
     * - Maintien du bouton rouge => enregistrement
     * - Graphe en temps réel (RMS) avec fenêtre glissante (par défaut 3 s)
     * - Au relâchement (> 2 s), émission de l'event
     *   client_transfer_medias(client_id, data_type, datas)
     *   - data_type: "sound_graph" | "sound_track"
     *   - datas: tableau de niveaux (graph) OU audio compressé (webm/opus) + mimeType
     * - À la réception de "client_datas_receveid" => statut "son transmis" puis retour à l'état initial après 3 s
     */

    // ====== Configuration ======
    const MIN_DURATION_MS = 2000;               // Durée minimale pour envoyer
    let   MAX_DURATION_MS = 3000;               // Modifiable via l'UI
    const SAMPLE_HZ = 60;                        // Fréquence d'échantillonnage du graphe
    const GRAPH_SECONDS_DEFAULT = 3;             // Fenêtre par défaut
    const USE_MEDIARECORDER = true;              // Compression via MediaRecorder (webm/opus) quand possible

    // ====== Éléments de l'UI ======
    const app = document.getElementById('app');
    const statusEl = document.getElementById('status');
    const hintEl = document.getElementById('hint');
    const btn = document.getElementById('recordBtn');
    const modeSelect = document.getElementById('mode');
    const maxSecInput = document.getElementById('maxSec');
    const sockState = document.getElementById('sockState');
    const sockDot = document.getElementById('sockDot');

    // Canvas/graphe
    const canvas = document.getElementById('scope');
    const ctx = canvas.getContext('2d');
    const cursor = document.getElementById('cursor');

    // ====== Socket.IO ======
    const socket = typeof io !== 'undefined' ? io() : null;
    const client_id = localStorage.getItem('client_id') || ("client-" + Math.random().toString(36).slice(2));
    localStorage.setItem('client_id', client_id);

    if (socket) {
      socket.on('connect', () => { sockDot.classList.add('ok'); });
      socket.on('disconnect', () => { sockDot.classList.remove('ok'); });

      // Accusé de réception serveur
      socket.on('client_datas_receveid', (payload) => {
        // payload: { client_id, ok?:boolean }
        showStatus('Son transmis', true);
        setTimeout(() => showStatus(''), 3000);
      });
    }

    // ====== Audio / Web Audio ======
    let audioStream = null;
    let audioCtx = null;
    let analyser = null;
    let source = null;
    let dataArray = null; // time domain buffer

    // Enregistrement brut
    let mediaRecorder = null;
    let chunks = [];

    // Graphe (tampon circulaire sur ~3s)
    let graphHz = SAMPLE_HZ;       // points par seconde
    let graphSeconds = GRAPH_SECONDS_DEFAULT;
    let graphCapacity = graphHz * graphSeconds; // nombre de points conservés
    let graph = new Float32Array(graphCapacity); // valeurs 0..1
    let graphIndex = 0;            // index circulaire courant
    let isRecording = false;
    let startTime = 0;
    let pollTimer = null;          // timer d'échantillonnage RMS
    let rafId = null;              // animation du rendu

    // ====== Utilitaires ======
    function setMaxDurationFromUI() {
      const v = Math.max(1, Math.min(10, Number(maxSecInput.value) || 3));
      MAX_DURATION_MS = v * 1000;
      graphSeconds = v;
      resizeGraphBuffer();
    }

    function resizeGraphBuffer() {
      graphCapacity = Math.max(1, Math.floor(graphSeconds * graphHz));
      graph = new Float32Array(graphCapacity);
      graphIndex = 0;
      drawGraph();
    }

    function showStatus(text, ok=false) {
      statusEl.textContent = text;
      statusEl.style.color = ok ? 'var(--ok)' : 'var(--muted)';
    }

    function now() { return performance.now(); }

    // Calcul RMS (root mean square) depuis l'onde temporelle
    function computeRMS() {
      if (!analyser) return 0;
      analyser.getByteTimeDomainData(dataArray);
      // signal centré ~128, normaliser en [-1,1]
      let sum = 0;
      for (let i=0;i<dataArray.length;i++) {
        const v = (dataArray[i]-128)/128;
        sum += v*v;
      }
      const rms = Math.sqrt(sum / dataArray.length); // 0..~1
      // Lisser pour un rendu plus propre
      return Math.min(1, Math.max(0, rms));
    }

    function pushGraphValue(v) {
      graph[graphIndex] = v;
      graphIndex = (graphIndex + 1) % graphCapacity;
    }

    // Dessin du graphe + curseur
    function drawGraph() {
      const w = canvas.width, h = canvas.height;
      ctx.clearRect(0,0,w,h);

      // Axes/ligne zéro
      ctx.globalAlpha = 1;
      ctx.lineWidth = 1;
      ctx.strokeStyle = '#1e232a';
      ctx.beginPath();
      ctx.moveTo(0, h-30.5);
      ctx.lineTo(w, h-30.5);
      ctx.stroke();

      // Polyline des niveaux (0 bas -> 1 haut)
      ctx.lineWidth = 2;
      ctx.strokeStyle = '#5ee1a2';
      ctx.beginPath();
      const stepX = w / Math.max(1, graphCapacity-1);
      // Le buffer est circulaire: on repart de graphIndex
      for (let i=0;i<graphCapacity;i++) {
        const idx = (graphIndex + i) % graphCapacity;
        const x = i * stepX;
        const y = h - 30 - (graph[idx] * (h-50)); // marges 20/30
        if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();

      // Position du curseur (avance pendant l'enregistrement)
      const elapsed = isRecording ? (now() - startTime) : 0;
      const cycle = MAX_DURATION_MS; // la barre parcourt la fenêtre en MAX_DURATION_MS
      const frac = isRecording ? Math.min(1, (elapsed % cycle) / cycle) : 0;
      const xCursor = Math.floor(frac * w);
      cursor.style.left = xCursor + 'px';
    }

    // Boucle de rendu
    function loopRender() {
      drawGraph();
      rafId = requestAnimationFrame(loopRender);
    }

    // Sampling du niveau sonore
    function startPolling() {
      if (pollTimer) clearInterval(pollTimer);
      pollTimer = setInterval(() => {
        const v = computeRMS();
        pushGraphValue(v);
      }, 1000 / graphHz);
    }
    function stopPolling() {
      if (pollTimer) { clearInterval(pollTimer); pollTimer = null; }
    }

    // Démarrage audio (permissions micro)
    async function ensureAudio() {
      if (audioStream && audioCtx) return;
      audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      analyser = audioCtx.createAnalyser();
      analyser.fftSize = 2048;
      dataArray = new Uint8Array(analyser.frequencyBinCount * 2); // time domain buffer length = fftSize
      source = audioCtx.createMediaStreamSource(audioStream);
      source.connect(analyser);
    }

    // Prépare MediaRecorder pour compression (webm/opus)
    function setupMediaRecorder() {
      if (!USE_MEDIARECORDER) return;
      const can = window.MediaRecorder && MediaRecorder.isTypeSupported ?
        (MediaRecorder.isTypeSupported('audio/webm;codecs=opus') ? 'audio/webm;codecs=opus' :
         (MediaRecorder.isTypeSupported('audio/webm') ? 'audio/webm' : null)) : null;
      if (!can) return;
      try {
        mediaRecorder = new MediaRecorder(audioStream, { mimeType: can, audioBitsPerSecond: 96000 });
        chunks = [];
        mediaRecorder.ondataavailable = e => { if (e.data && e.data.size) chunks.push(e.data); };
      } catch (e) { mediaRecorder = null; }
    }

    // ====== Flux principal: start/stop record ======
    async function startRecord() {
      if (isRecording) return;
      await ensureAudio();
      setupMediaRecorder();

      // Reset graphe
      graph.fill(0); graphIndex = 0; drawGraph();

      // MediaRecorder start (si dispo)
      if (mediaRecorder) {
        chunks = [];
        try { mediaRecorder.start(); } catch {}
      }

      isRecording = true;
      startTime = now();
      app.classList.add('recording');
      hintEl.style.opacity = 0.15;
      showStatus('Enregistrement…');

      startPolling();
      if (!rafId) loopRender();

      // Arrêt auto à MAX_DURATION_MS + petit tampon pour garantir > MIN si utilisateur reste appuyé
      setTimeout(() => { if (isRecording) stopRecord(true); }, MAX_DURATION_MS + 50);
    }

    async function stopRecord(auto=false) {
      if (!isRecording) return;
      isRecording = false;
      stopPolling();

      // Stop MediaRecorder et récupérer le blob compressé (si mode son intégral)
      let audioBlob = null, mimeType = '';
      if (mediaRecorder) {
        const done = new Promise(res => {
          mediaRecorder.onstop = () => res();
        });
        try { mediaRecorder.stop(); } catch {}
        await done;
        if (chunks.length) {
          audioBlob = new Blob(chunks, { type: mediaRecorder.mimeType || 'audio/webm' });
          mimeType = audioBlob.type;
        }
      }

      const duration = now() - startTime;
      app.classList.remove('recording');

      // Conditions d'envoi
      if (duration < MIN_DURATION_MS) {
        showStatus(`Enregistrement trop court (${Math.round(duration)} ms)`, false);
        setTimeout(() => showStatus(''), 1600);
        return;
      }

      // Préparer payload selon le mode
      const mode = modeSelect.value; // 'sound_graph' | 'sound_track'
      let payload = null;

      if (mode === 'sound_graph') {
        // Export du graphe sur la dernière fenêtre
        // Recomposer dans l'ordre chronologique
        const out = new Float32Array(graphCapacity);
        for (let i=0;i<graphCapacity;i++) out[i] = graph[(graphIndex + i) % graphCapacity];
        payload = {
          client_id,
          data_type: 'sound_graph',
          datas: {
            sample_hz: graphHz,
            window_seconds: graphSeconds,
            values: Array.from(out)
          }
        };
      } else {
        // Son intégral compressé
        if (!audioBlob) {
          showStatus('Impossible de récupérer l’audio (MediaRecorder indisponible).', false);
          return;
        }
        const arrayBuf = await audioBlob.arrayBuffer();
        // Envoi binaire possible avec Socket.IO directement
        payload = {
          client_id,
          data_type: 'sound_track',
          datas: {
            mimeType,
            buffer: new Uint8Array(arrayBuf)  // Socket.IO gère le binaire
          }
        };
      }

      // Émission Socket.IO
      if (socket) {
        socket.emit('client_transfer_medias', payload);
        showStatus('Envoi…');
      } else {
        showStatus('Socket non disponible', false);
      }
    }

    // ====== Interactions ======
    function down() { startRecord(); }
    function up() { stopRecord(false); }

    btn.addEventListener('mousedown', down);
    btn.addEventListener('touchstart', (e) => { e.preventDefault(); down(); }, { passive: false });
    window.addEventListener('mouseup', up);
    window.addEventListener('touchend', up);

    // Raccourci clavier (Espace)
    let keyHeld = false;
    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space' && !keyHeld) { keyHeld = true; e.preventDefault(); down(); }
    });
    window.addEventListener('keyup', (e) => {
      if (e.code === 'Space') { keyHeld = false; e.preventDefault(); up(); }
    });

    // Changement durée max
    maxSecInput.addEventListener('input', () => setMaxDurationFromUI());
    setMaxDurationFromUI();

    // Dessin initial
    drawGraph();
  })();
  </script>
</body>
</html>
